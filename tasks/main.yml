---
# tasks file for stefanhorning.ubuntu_hetzner_cloud

- name: Ping as defined custom user to see if user already exists
  ping:
  remote_user: "{{ hetzner_cloud_custom_user }}"
  ignore_errors: true
  register: user_exists

- name: Set run_role_as_user to either root (if this is initial run) or {{ hetzner_cloud_custom_user }} on a rerun of this role
  set_fact:
    run_role_as_user: "{{ hetzner_cloud_custom_user }}"

- set_fact:
    run_role_as_user: root
  when: user_exists.failed

- name: Output Linux OS version
  remote_user: "{{ run_role_as_user }}"
  debug:
    msg: "Family: {{ ansible_os_family }} | Distro: {{ ansible_distribution }} | Version: {{ ansible_distribution_version }}"

- name: Output Python version that Ansible is currently using
  remote_user: "{{ run_role_as_user }}"
  debug:
    var: ansible_python_version

- name: Upgrade all installed apt packages
  remote_user: "{{ run_role_as_user }}"
  become: true
  apt:
    upgrade: dist
    update_cache: yes
  when: hetzner_cloud_update_apt|bool

- name: Install useful apt packages
  remote_user: "{{ run_role_as_user }}"
  become: true
  apt:
    name: "{{ hetzner_cloud_essential_packages }}"
    state: present

- name: Run apt clean-ups
  remote_user: "{{ run_role_as_user }}"
  become: true
  apt:
    autoremove: true
    autoclean: true
  when: hetzner_cloud_update_apt|bool

- name: Make sure we have a wheel group for sudoing
  remote_user: "{{ run_role_as_user }}"
  become: true
  group:
    name: wheel
    state: present

- name: Allow wheel group to have passwordless sudo
  remote_user: "{{ run_role_as_user }}"
  become: true
  lineinfile:
    dest: /etc/sudoers
    regexp: '^%wheel'
    line: '%wheel ALL=(ALL) NOPASSWD: ALL'
    validate: 'visudo -cf %s'
    state: present

- name: Setup custom system user
  remote_user: "{{ run_role_as_user }}"
  become: true
  user:
    name: "{{ hetzner_cloud_custom_user }}"
    shell: /bin/bash
    comment: Admin User
    create_home: true
    append: yes
    groups: wheel
    state: present

- name: Make sure .ssh dir exists for custom user
  remote_user: "{{ run_role_as_user }}"
  file:
    path: /home/{{ hetzner_cloud_custom_user }}/.ssh/
    state: directory
    owner: "{{ hetzner_cloud_custom_user }}"
    mode: 0600

- name: Move public ssh keys from root user to custom user (when running as root)
  remote_user: "{{ run_role_as_user }}"
  copy:
    remote_src: true
    src: /home/root/.ssh/authorized_keys
    dest: /home/{{ hetzner_cloud_custom_user }}/.ssh/authorized_keys
    owner: "{{ hetzner_cloud_custom_user }}"
    mode: 0600
  when: run_role_as_user == 'root'

- name: Update SSH config to disallow root login
  remote_user: "{{ run_role_as_user }}"
  become: true
  lineinfile:
    path: /etc/ssh/sshd_config
    regex: '^PermitRootLogin'
    line: 'PermitRootLogin no'
  state: present

- name: Update SSH config to disallow password auth
  remote_user: "{{ run_role_as_user }}"
  become: true
  lineinfile:
    path: /etc/ssh/sshd_config
    regex: '^PasswordAuthentication'
    line: 'PasswordAuthentication no'
  state: present

- name: Update SSH config to use custom port
  remote_user: "{{ run_role_as_user }}"
  become: true
  lineinfile:
    path: /etc/ssh/sshd_config
    regex: '^Port'
    line: 'Port {{ hetzner_cloud_ssh_port }}'
  state: present

- name: Install UFW firewall
  remote_user: "{{ run_role_as_user }}"
  become: true
  apt:
    name: ufw
  state: present

- name: Set UFW rule to deny incomming traffic by default
  remote_user: "{{ run_role_as_user }}"
  become: true
  ufw:
    direction: incoming
    default: deny

- name: Set UFW rule to allow outgoing traffic by default
  remote_user: "{{ run_role_as_user }}"
  become: true
  ufw:
    direction: outgoing
    default: allow

- name: Ensure configured SSH port is still opened UFW
  remote_user: "{{ run_role_as_user }}"
  become: true
  ufw:
    rule: allow
    port: "{{ hetzner_cloud_ssh_port }}"
    proto: tcp

- name: Add other ports to allow incomming traffic from
  remote_user: "{{ run_role_as_user }}"
  become: true
  ufw:
    rule: allow
    port: "{{ item.port }}"
    proto: tcp
  with_items: "{{ hetzner_cloud_open_ports }}"

- name: Restart SSHd server to switch to new port (use new port and user after this)
  remote_user: "{{ run_role_as_user }}"
  become: true
  service:
    name: sshd
    state: restarted
    enabled: true

- name: Output infos
  debug:
    msg: Now use {{ hetzner_cloud_custom_user }} and port {{ hetzner_cloud_ssh_port }} to SSH to machine now (remaining role tasks do this automatically)

- name: Enabled Firewall rules (only allows whitelisted ports after this)
  remote_user: "{{ hetzner_cloud_custom_user }}"
  ansible_port: "{{ hetzner_cloud_ssh_port }}"
  become: true
  ufw:
    state: enabled
  register: ufw_results

- name: Output UWF results
  debug:
    var: ufw_results
